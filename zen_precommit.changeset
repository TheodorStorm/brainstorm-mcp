diff --git a/CHANGELOG.md b/CHANGELOG.md
index 85c0f80..5959a00 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -7,6 +7,46 @@ and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0
 
 ## [Unreleased]
 
+## [0.8.0] - 2025-10-13
+
+### Added
+- **Session Persistence** - Automatic client tracking across restarts
+  - Working directory-based client IDs (deterministic SHA-256 hash)
+  - `join_project` now requires `working_directory` parameter for session tracking
+  - `status` tool now shows all projects for your working directory (replaces agent_name parameter)
+  - Client membership records persist across sessions
+  - Project deletion automatically cleans up client memberships
+- **Legacy Member Migration** - Seamless upgrade path from pre-v0.8.0
+  - Agent names without `client_id` can be reclaimed by any client (convenience for local use)
+  - Identity continuity preserved: `agent_id` and `joined_at` kept from legacy member
+  - Automatic backfill of `client_id` when legacy names are claimed
+- **MCP Prompts** - 8 conversational prompts for guided workflows (zero-parameter design)
+  - `list` - List all projects (no arguments needed!)
+  - `status` - Show your status across projects
+  - `create` - Create project and auto-join with conflict detection
+  - `join` - Join with role suggestions and current member list
+  - `broadcast` - Send to all with guided reply_expected usage
+  - `review` - Full project dashboard (members, messages, resources)
+  - `share` - Publish resources with team notification
+  - `discuss` - Reply with recent message context
+- **Context Injection** - Prompts query storage to inject real-time state
+  - Current members with online/offline status
+  - Recent messages and unread counts
+  - Available resources and suggested roles
+  - Existing project IDs and conflict warnings
+- **Smart Inference** - Prompts intelligently suggest values
+  - Conversational parameter gathering (prompts ask for missing info)
+  - Auto-detect reply_expected from message content (questions, requests)
+  - Suggest available roles based on existing team members
+  - Generate safe IDs from human-readable names
+- **Enhanced reply_expected Guidance** - Comprehensive usage instructions
+  - Tool description emphasizes binding commitment ("CRITICAL" prefix)
+  - Parameter description clarifies when to use true vs false
+  - Three messaging prompts (broadcast, share, discuss) include detailed guidance
+  - Clear decision heuristics: questions/requests ‚Üí true, informational ‚Üí false
+- **Comprehensive prompt documentation** in new PROMPTS.md file
+- **Discovery-first design** - Start with zero-argument `list` prompt, then explore
+
 ## [0.6.0] - 2025-10-09
 
 ### Added
diff --git a/CLAUDE.md b/CLAUDE.md
index fefa530..05d2f81 100644
--- a/CLAUDE.md
+++ b/CLAUDE.md
@@ -78,6 +78,7 @@ Default storage location: `~/.brainstorm`
 1. **MCP Protocol Layer** (`src/server.ts`)
    - `AgentCoopServer` class implements the MCP server
    - Exposes 15 tools for agent cooperation (create_project, delete_project, join_project, send_message, receive_messages, acknowledge_message, store_resource, get_resource, list_resources, delete_resource, get_project_info, list_projects, heartbeat, version, status)
+   - Provides 8 context-aware prompts (list, mystatus, create, join, broadcast, review, share, discuss)
    - Uses stdio transport for communication with MCP clients
    - All tool handlers map to storage layer operations
 
@@ -162,6 +163,34 @@ Default storage location: `~/.brainstorm`
 
 The configuration script (`scripts/configure-mcp.js`) handles building the project and updating the config file with the correct absolute path.
 
+## Shell Wrapper for Auto-Check on Startup
+
+To automatically check Brainstorm status when starting Claude Code, add this wrapper function to your `~/.zshrc` (or `~/.bashrc`):
+
+```bash
+# Claude Code smart wrapper - auto-check Brainstorm on startup
+claude() {
+  # If no arguments provided, check Brainstorm status first
+  if [ $# -eq 0 ]; then
+    command claude "Check brainstorm status using mcp__brainstorm__status with working_directory from <env>, then wait for my instructions"
+  else
+    command claude "$@"
+  fi
+}
+```
+
+After adding this function, reload your shell configuration:
+
+```bash
+source ~/.zshrc
+```
+
+**How it works**:
+- `claude` (no arguments) ‚Üí Automatically checks Brainstorm status and shows active projects/unread messages
+- `claude "your prompt"` ‚Üí Works normally, passes your prompt through unchanged
+
+This ensures you never miss important Brainstorm notifications when starting a new Claude Code session.
+
 ## Version Management
 
 Version information is stored in a single source of truth: `package.json`
@@ -248,6 +277,76 @@ All identifiers in tests use valid characters. When adding features, ensure secu
 7. Add types to `src/types.ts` if new data structures are needed
 8. Add security tests to `tests/security.test.ts`
 
+## MCP Prompts (v0.8.0)
+
+Brainstorm provides **context-aware prompts** that wrap tools with intelligent guidance:
+
+### How Prompts Work
+
+Prompts are **not tools** - they're guided workflows that:
+1. Accept high-level arguments from Claude Code
+2. Query the storage layer for real-time state (projects, members, messages, resources)
+3. Inject context into the prompt text
+4. Return instructions telling Claude which tools to call and with what parameters
+
+### Available Prompts
+
+- **`list`**: List all projects (NO args - discovery!)
+- **`status`**: Show your status across projects (only agent_name)
+- **`create`**: Create project + auto-join with conflict detection
+- **`join`**: Join project with role suggestions and member list
+- **`broadcast`**: Send to all with auto-inferred reply_expected
+- **`review`**: Full project dashboard (members, messages, resources)
+- **`share`**: Publish resource + notify team
+- **`discuss`**: Reply with recent message context
+
+### Adding New Prompts
+
+1. Add prompt definition to `PROMPTS` constant in `src/server.ts`:
+   ```typescript
+   'my-prompt': {
+     name: 'my-prompt',
+     description: 'What this prompt does',
+     arguments: [
+       { name: 'arg1', description: '...', required: true }
+     ]
+   }
+   ```
+
+2. Add case to `GetPromptRequestSchema` handler switch statement:
+   ```typescript
+   case 'my-prompt': {
+     const arg1 = args.arg1 as string;
+
+     // Query storage for context
+     const context = await this.storage.getSomeState(...);
+
+     // Generate prompt text with instructions
+     return {
+       messages: [{
+         role: 'user',
+         content: {
+           type: 'text',
+           text: `Here's what I want to do: ${arg1}
+
+           **Context**: ${context}
+
+           Please use these tools:
+           - \`tool_name\` with param1="${arg1}"`
+         }
+       }]
+     };
+   }
+   ```
+
+3. **Best practices**:
+   - Query storage to inject real-time state
+   - Use markdown formatting for clarity
+   - Provide specific tool instructions with exact parameters
+   - Handle error cases (e.g., project not found)
+   - Show contextual information (who's online, what's available)
+   - Use smart defaults and inference where appropriate
+
 ## Storage Migration Path
 
 When migrating to a database:
diff --git a/README.md b/README.md
index 6a60c84..5c74222 100644
--- a/README.md
+++ b/README.md
@@ -19,6 +19,7 @@ DISCLAIMER: This status of this project is "works on my computer‚Ñ¢". I hope it
 
 ## Features
 
+- **Context-Aware Prompts**: 8 intelligent prompts with real-time state injection for guided workflows
 - **Project-Based Organization**: Projects are the organizing unit‚Äîagents join projects with friendly names
 - **Natural Communication**: Send messages using simple names like "frontend" or "backend"
 - **Shared Context**: Project descriptions and goals automatically visible to all members
@@ -28,6 +29,79 @@ DISCLAIMER: This status of this project is "works on my computer‚Ñ¢". I hope it
 - **File System Storage**: Simple file-based storage for easy deployment (no database required)
 - **Audit Logging**: Track all interactions for debugging and compliance
 
+## MCP Prompts
+
+Brainstorm provides **context-aware prompts** that make multi-agent workflows intuitive. Prompts automatically inject project state (members, messages, resources) to enable intelligent suggestions and error prevention.
+
+### Available Prompts
+
+#### üìã list
+List all available projects (no arguments needed!).
+- **Zero friction**: No arguments required - just run it
+- **Perfect for discovery**: See what projects exist before joining
+- **Use case**: First thing to run when you connect to Brainstorm
+
+#### üë§ status
+Show your status across all projects.
+- **Minimal args**: Just your agent name
+- **Shows**: Which projects you're in, unread message counts
+- **Use case**: Quick overview of your activity
+
+#### üöÄ create
+Create a new project and automatically join as first member.
+- **Context**: Checks for existing project ID conflicts, warns if project already exists
+- **Smart defaults**: Generates safe project ID from name, defaults role to "coordinator"
+- **Use case**: Fastest way to initialize a new multi-agent collaboration
+
+#### ü§ù join
+Join an existing project with role suggestions.
+- **Context**: Shows current members with online status, project metadata
+- **Smart suggestions**: Recommends available roles not yet taken (frontend, backend, reviewer, tester, coordinator)
+- **Helpful errors**: Lists all available projects if target doesn't exist
+
+#### üì¢ broadcast
+Send message to all project members.
+- **Context**: Shows recipient list and count
+- **Smart inference**: Detects questions/requests in message, sets `reply_expected` automatically
+- **Use case**: Announcements, questions, coordination messages
+
+#### üìä review
+Get comprehensive project status dashboard.
+- **Context**: Full situational awareness
+  - All members with online/offline status and last seen times
+  - Unread messages (preview of last 5)
+  - Available resources with descriptions
+  - Suggested next actions
+- **Use case**: "Catch up on project" - essential for async collaboration
+
+#### üì¶ share
+Publish resource with team notification.
+- **Context**: Shows who will receive the resource, member list
+- **Smart defaults**: Generates resource ID from title, sets appropriate permissions
+- **Workflow**: Store resource + broadcast notification in one step
+
+#### üí¨ discuss
+Reply to ongoing discussion with context.
+- **Context**: Shows last 3 messages with reply status
+- **Smart guidance**: Suggests whether to broadcast or direct message based on discussion
+- **Use case**: Responding to team discussions with full context
+
+### Using Prompts vs Tools
+
+**Prompts** (Recommended for most workflows):
+- Guided experiences with context-awareness
+- Smart suggestions, validation, and error handling
+- Real-time project state injection
+- Best for: Onboarding, common patterns, quick actions
+
+**Tools** (Advanced/Custom workflows):
+- Direct control with precise parameters
+- No context injection - you specify everything
+- Required for: Custom logic, game mechanics, specialized protocols
+- Best for: Demos, complex choreography, fine-grained control
+
+For detailed prompt documentation with examples, see [PROMPTS.md](PROMPTS.md).
+
 ## Installation
 
 ```bash
@@ -443,6 +517,98 @@ Update your online status. Call periodically to show you're active.
 }
 ```
 
+#### `status`
+Get status across all projects. Supports two modes:
+- **Agent-specific**: `status(agent_name="frontend")` - shows projects for that agent name only
+- **Client-wide**: `status(client_id="...")` - shows ALL projects this Claude instance has joined
+
+```typescript
+// First time - get new client_id
+{}  // Returns: {client_id: "abc-123", projects: []}
+
+// Check all projects for this client
+{
+  client_id: "abc-123"
+}
+
+// Or check specific agent name
+{
+  agent_name: "frontend"
+}
+```
+
+## Session Persistence
+
+Brainstorm automatically remembers which projects you've joined across sessions, allowing seamless collaboration resumption.
+
+### How It Works
+
+Each Claude Code instance gets a persistent **client_id** (UUID) that tracks all project memberships regardless of agent name. This solves the problem of joining multiple projects with different agent names:
+
+- Join project "api-redesign" as "backend-dev"
+- Join project "frontend-work" as "ui-specialist"
+- Join project "testing" as "qa-lead"
+
+All three memberships are remembered under your client_id.
+
+### Automatic Workflow
+
+**First Time:**
+```typescript
+// Call status with no parameters to get your client_id
+status()
+‚Üí { client_id: "550e8400-e29b-41d4-a716-446655440000", projects: [] }
+
+// Join a project - client_id auto-generated if not provided
+join_project({
+  project_id: "api-redesign",
+  agent_name: "backend-dev",
+  client_id: "550e8400-..."  // Optional but recommended
+})
+‚Üí { success: true, client_id: "550e8400-...", client_id_is_new: false }
+```
+
+**Future Sessions:**
+```typescript
+// Check all your projects
+status({ client_id: "550e8400-..." })
+‚Üí {
+    client_id: "550e8400-...",
+    projects: [
+      {
+        project_id: "api-redesign",
+        agent_name: "backend-dev",
+        project_name: "API Redesign",
+        unread_messages: 2
+      },
+      {
+        project_id: "frontend-work",
+        agent_name: "ui-specialist",
+        project_name: "Frontend Refresh",
+        unread_messages: 0
+      }
+    ]
+  }
+```
+
+### Storage Structure
+
+Client memberships are stored in:
+```
+~/.brainstorm/
+  clients/
+    <client-id>/
+      identity.json        # {client_id, created_at, last_seen}
+      memberships.json     # [{project_id, agent_name, project_name, joined_at}]
+```
+
+### Key Features
+
+- **Zero Configuration**: Client IDs are automatically generated on first use
+- **Server-Side Storage**: No client-side state management required
+- **Multi-Project Support**: One client can join many projects with different names
+- **Automatic Cleanup**: Deleted projects are automatically removed from all client memberships
+
 ## Usage Examples
 
 ### Example 1: Cross-Project Code Review
diff --git a/demos/debate/TOPIC.md b/demos/debate/TOPIC.md
index efee671..c22b45e 100644
--- a/demos/debate/TOPIC.md
+++ b/demos/debate/TOPIC.md
@@ -1,3 +1,4 @@
 # Debate Topic
 
-Consciousness cannot be reduced to physical processes.
+Generative AI is the biggest threat to humanity since the atomic bomb.
+
diff --git a/package.json b/package.json
index 24aa9e0..617d65f 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "brainstorm",
-  "version": "0.7.0",
+  "version": "0.8.0",
   "description": "MCP server enabling multi-agent collaboration and coordination",
   "type": "module",
   "main": "dist/src/index.js",
diff --git a/src/server.ts b/src/server.ts
index f0757ac..efcc9b5 100644
--- a/src/server.ts
+++ b/src/server.ts
@@ -7,9 +7,11 @@ import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js'
 import {
   CallToolRequestSchema,
   ListToolsRequestSchema,
+  ListPromptsRequestSchema,
+  GetPromptRequestSchema,
   Tool
 } from '@modelcontextprotocol/sdk/types.js';
-import { randomUUID } from 'crypto';
+import { randomUUID, createHash } from 'crypto';
 import { readFileSync, existsSync } from 'fs';
 import { join, dirname } from 'path';
 import { fileURLToPath } from 'url';
@@ -22,6 +24,16 @@ import type {
   ResourceManifest
 } from './types.js';
 
+/**
+ * Generate deterministic client ID from working directory path
+ * Same directory always produces the same client_id for automatic session persistence
+ */
+function generateDeterministicClientId(workingDirectory: string): string {
+  const hash = createHash('sha256').update(workingDirectory).digest('hex');
+  // Format as UUID: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
+  return `${hash.substring(0, 8)}-${hash.substring(8, 12)}-${hash.substring(12, 16)}-${hash.substring(16, 20)}-${hash.substring(20, 32)}`;
+}
+
 // Load version info with fallback to package.json
 const __filename = fileURLToPath(import.meta.url);
 const __dirname = dirname(__filename);
@@ -70,6 +82,50 @@ export class AgentCoopServer {
   private activeLongPolls = new Map<string, number>();
   private readonly MAX_CONCURRENT_POLLS = 100;
 
+  // MCP Prompts for guided multi-agent workflows
+  private readonly PROMPTS = {
+    'create': {
+      name: 'create',
+      description: 'Create a new multi-agent collaboration project. I\'ll ask you for the details conversationally.',
+      arguments: []
+    },
+    'join': {
+      name: 'join',
+      description: 'Join an existing collaboration project. I\'ll show you available projects and help you choose.',
+      arguments: []
+    },
+    'broadcast': {
+      name: 'broadcast',
+      description: 'Send a message to all agents in a project. I\'ll help you compose and send it.',
+      arguments: []
+    },
+    'review': {
+      name: 'review',
+      description: 'Catch up on project activity. I\'ll show you members, messages, and resources.',
+      arguments: []
+    },
+    'share': {
+      name: 'share',
+      description: 'Share a resource or document with the project team. I\'ll guide you through the process.',
+      arguments: []
+    },
+    'discuss': {
+      name: 'discuss',
+      description: 'Reply to ongoing project discussions. I\'ll show you recent context and help you respond.',
+      arguments: []
+    },
+    'list': {
+      name: 'list',
+      description: 'List all available projects. Perfect for discovery - no arguments needed!',
+      arguments: []
+    },
+    'status': {
+      name: 'status',
+      description: 'Show your Brainstorm project memberships for this working directory.',
+      arguments: []
+    }
+  };
+
   constructor(storagePath: string) {
     this.storage = new FileSystemStorage(storagePath);
 
@@ -80,7 +136,8 @@ export class AgentCoopServer {
       },
       {
         capabilities: {
-          tools: {}
+          tools: {},
+          prompts: {}
         }
       }
     );
@@ -160,7 +217,7 @@ export class AgentCoopServer {
         },
         {
           name: 'join_project',
-          description: 'Join a project with a friendly agent name. This is how agents register themselves within a project.',
+          description: 'Join a project with a friendly agent name. This is how agents register themselves within a project. Automatically tracks membership by your working directory - no manual storage needed!',
           inputSchema: {
             type: 'object',
             properties: {
@@ -172,6 +229,10 @@ export class AgentCoopServer {
                 type: 'string',
                 description: 'Your friendly name within this project (e.g., "frontend", "backend")'
               },
+              working_directory: {
+                type: 'string',
+                description: 'Absolute path to your project directory - provides automatic session persistence'
+              },
               capabilities: {
                 type: 'array',
                 items: { type: 'string' },
@@ -182,7 +243,7 @@ export class AgentCoopServer {
                 description: 'Key-value labels for this agent'
               }
             },
-            required: ['project_id', 'agent_name']
+            required: ['project_id', 'agent_name', 'working_directory']
           }
         },
         {
@@ -219,7 +280,7 @@ export class AgentCoopServer {
         },
         {
           name: 'send_message',
-          description: 'Send a message to another agent in the project or broadcast to all members. Set reply_expected=true if you will wait for a response, false if not.',
+          description: 'Send a message to another agent in the project or broadcast to all members. CRITICAL: reply_expected is a commitment - set true ONLY if you will immediately call receive_messages with wait=true to wait for responses. Set false for informational messages.',
           inputSchema: {
             type: 'object',
             properties: {
@@ -241,7 +302,7 @@ export class AgentCoopServer {
               },
               reply_expected: {
                 type: 'boolean',
-                description: 'True if you will call receive_messages to wait for a reply, false otherwise'
+                description: 'CRITICAL: Set true if your message asks a question or requests action AND you will immediately call receive_messages with wait=true to wait for replies. Set false for informational messages. This is a binding commitment - true means you WILL wait, false means you won\'t.'
               },
               payload: {
                 type: 'object',
@@ -492,16 +553,16 @@ export class AgentCoopServer {
         },
         {
           name: 'status',
-          description: 'Get agent status across all projects. Shows which projects the agent is a member of and whether there are unread messages in each project.',
+          description: 'Get your Brainstorm project status. Shows project memberships for your working directory with seamless session persistence - same directory always shows the same projects.',
           inputSchema: {
             type: 'object',
             properties: {
-              agent_name: {
+              working_directory: {
                 type: 'string',
-                description: 'Agent name to check status for'
+                description: 'Absolute path to your project directory - shows all projects joined from this directory'
               }
             },
-            required: ['agent_name']
+            required: ['working_directory']
           }
         }
       ];
@@ -558,10 +619,18 @@ export class AgentCoopServer {
           }
 
           case 'join_project': {
+            const projectId = args.project_id as string;
+            const agentName = args.agent_name as string;
+            const workingDirectory = args.working_directory as string;
+
+            // Generate deterministic client_id from working directory
+            const clientId = generateDeterministicClientId(workingDirectory);
+
             const member: ProjectMember = {
-              project_id: args.project_id as string,
-              agent_name: args.agent_name as string,
+              project_id: projectId,
+              agent_name: agentName,
               agent_id: randomUUID(),
+              client_id: clientId, // Include client_id for name reclaiming
               capabilities: (args.capabilities as string[]) || [],
               labels: (args.labels as Record<string, string>) || {},
               joined_at: new Date().toISOString(),
@@ -571,12 +640,20 @@ export class AgentCoopServer {
 
             await this.storage.joinProject(member);
 
+            // Get project metadata for the membership record
+            const projectMetadata = await this.storage.getProjectMetadata(projectId);
+            const projectName = projectMetadata?.name || projectId;
+
+            // Store client identity and record membership
+            await this.storage.storeClientIdentity(clientId);
+            await this.storage.recordClientMembership(clientId, projectId, agentName, projectName);
+
             await this.storage.auditLog({
               timestamp: new Date().toISOString(),
               actor: member.agent_name,
               action: 'join_project',
               target: member.project_id,
-              details: { agent_id: member.agent_id }
+              details: { agent_id: member.agent_id, client_id: clientId, working_directory: workingDirectory }
             });
 
             return {
@@ -584,9 +661,10 @@ export class AgentCoopServer {
                 type: 'text',
                 text: JSON.stringify({
                   success: true,
+                  working_directory: workingDirectory,
                   agent_name: member.agent_name,
                   agent_id: member.agent_id,
-                  message: 'Joined project successfully. You can now send and receive messages.'
+                  message: 'Joined project successfully. Your membership is automatically tracked by your working directory.'
                 }, null, 2)
               }]
             };
@@ -1133,6 +1211,9 @@ export class AgentCoopServer {
 
             await this.storage.deleteProject(projectId, agentName);
 
+            // Cleanup: remove this project from all client membership files
+            await this.storage.removeProjectFromAllClients(projectId);
+
             await this.storage.auditLog({
               timestamp: new Date().toISOString(),
               actor: agentName,
@@ -1145,7 +1226,7 @@ export class AgentCoopServer {
                 type: 'text',
                 text: JSON.stringify({
                   success: true,
-                  message: 'Project deleted successfully'
+                  message: 'Project deleted successfully. All client memberships have been removed.'
                 }, null, 2)
               }]
             };
@@ -1161,30 +1242,35 @@ export class AgentCoopServer {
           }
 
           case 'status': {
-            const agentName = args.agent_name as string;
+            const workingDirectory = args.working_directory as string;
 
-            // Get all projects
-            const allProjects = await this.storage.listProjects();
-            const projectStatuses = [];
+            // Generate deterministic client_id from working directory
+            const clientId = generateDeterministicClientId(workingDirectory);
+
+            // Store/update client identity
+            await this.storage.storeClientIdentity(clientId);
 
-            // Check each project for membership and messages
-            for (const project of allProjects) {
-              const member = await this.storage.getProjectMember(project.project_id, agentName);
+            // Get memberships for this client
+            const memberships = await this.storage.getClientMemberships(clientId);
+            const projectStatuses = [];
 
-              if (member) {
-                // Agent is a member of this project
-                const messages = await this.storage.getAgentInbox(project.project_id, agentName);
+            for (const membership of memberships) {
+              try {
+                const messages = await this.storage.getAgentInbox(membership.project_id, membership.agent_name);
+                const member = await this.storage.getProjectMember(membership.project_id, membership.agent_name);
 
                 projectStatuses.push({
-                  project_id: project.project_id,
-                  project_name: project.name,
-                  description: project.description,
-                  joined_at: member.joined_at,
-                  last_seen: member.last_seen,
-                  online: member.online,
+                  project_id: membership.project_id,
+                  project_name: membership.project_name,
+                  agent_name: membership.agent_name,
+                  joined_at: membership.joined_at,
+                  last_seen: member?.last_seen || membership.joined_at,
+                  online: member?.online || false,
                   unread_messages: messages.length,
                   has_unread: messages.length > 0
                 });
+              } catch {
+                // Project might have been deleted - skip it
               }
             }
 
@@ -1192,7 +1278,7 @@ export class AgentCoopServer {
               content: [{
                 type: 'text',
                 text: JSON.stringify({
-                  agent_name: agentName,
+                  working_directory: workingDirectory,
                   projects: projectStatuses,
                   total_projects: projectStatuses.length,
                   total_unread_messages: projectStatuses.reduce((sum, p) => sum + p.unread_messages, 0)
@@ -1214,6 +1300,367 @@ export class AgentCoopServer {
         return this.formatError(error, name);
       }
     });
+
+    // List available prompts
+    this.server.setRequestHandler(ListPromptsRequestSchema, async () => {
+      return {
+        prompts: Object.values(this.PROMPTS)
+      };
+    });
+
+    // Handle prompt requests with contextual intelligence
+    this.server.setRequestHandler(GetPromptRequestSchema, async (request) => {
+      const promptName = request.params.name;
+      const args = request.params.arguments || {};
+
+      const prompt = this.PROMPTS[promptName as keyof typeof this.PROMPTS];
+      if (!prompt) {
+        throw new Error(`Prompt not found: ${promptName}`);
+      }
+
+      try {
+        switch (promptName) {
+          case 'create': {
+            // Get context: check current status and existing projects
+            const existingProjects = await this.storage.listProjects();
+
+            return {
+              messages: [
+                {
+                  role: 'user',
+                  content: {
+                    type: 'text',
+                    text: `I want to create a new multi-agent collaboration project.
+
+**First, let me check your current status:**
+1. Read your working directory from \`<env>\` (look for "Working directory:")
+2. Use the \`status\` tool with working_directory=[value from env]
+
+${existingProjects.length > 0 ? `\n**Existing projects** (${existingProjects.length}):\n${existingProjects.map(p => `- **${p.project_id}**: ${p.name}`).join('\n')}\n` : '**Note**: No projects exist yet - you\'ll be creating the first one!\n'}
+**Then, please ask me:**
+- What should the project be called?
+- What's the goal or purpose?
+- What role will you play? (e.g., "coordinator", "lead", "architect")
+
+**Once I provide this info, you'll:**
+1. Generate a project_id from the name (lowercase, alphanumeric + dashes)
+2. Check if it conflicts with existing projects
+3. Create it with \`create_project\`
+4. Join it automatically with \`join_project\``
+                  }
+                }
+              ]
+            };
+          }
+
+          case 'join': {
+            // List available projects for selection
+            const projects = await this.storage.listProjects();
+
+            if (projects.length === 0) {
+              return {
+                messages: [
+                  {
+                    role: 'user',
+                    content: {
+                      type: 'text',
+                      text: `‚ùå **No Projects Available**
+
+There are no collaboration projects to join yet.
+
+**Next steps**:
+- Use the **create** prompt to start a new project
+- Ask other agents to create a project first`
+                    }
+                  }
+                ]
+              };
+            }
+
+            const projectList = projects.map(p => {
+              return `### üìÅ ${p.name} (\`${p.project_id}\`)
+**Description**: ${p.description || '(No description)'}
+**Created**: ${new Date(p.created_at).toLocaleString()}`;
+            }).join('\n\n');
+
+            return {
+              messages: [
+                {
+                  role: 'user',
+                  content: {
+                    type: 'text',
+                    text: `I want to join a collaboration project.
+
+**First, let me check your current status:**
+1. Read your working directory from \`<env>\` (look for "Working directory:")
+2. Use the \`status\` tool to see which projects you're already in
+
+**Available Projects** (${projects.length}):
+
+${projectList}
+
+**Then, please ask me:**
+- Which project would you like to join? (provide the project_id)
+- What role will you play? (e.g., "frontend", "backend", "reviewer")
+
+**Once I provide this info, you'll:**
+1. Get detailed project info with \`get_project_info\` to see current members
+2. Suggest available roles based on existing members
+3. Join with \`join_project\`
+4. Check for unread messages with \`receive_messages\``
+                  }
+                }
+              ]
+            };
+          }
+
+          case 'broadcast': {
+            // Check status to determine which project to broadcast to
+            return {
+              messages: [
+                {
+                  role: 'user',
+                  content: {
+                    type: 'text',
+                    text: `I want to broadcast a message to all members of a project.
+
+**First, let me check your current status:**
+1. Read your working directory from \`<env>\` (look for "Working directory:")
+2. Use the \`status\` tool to see your active projects
+
+**Then:**
+- If you're in exactly 1 project ‚Üí I'll ask for the message and broadcast to that project
+- If you're in multiple projects ‚Üí I'll ask which project and what message
+- If you're in 0 projects ‚Üí I'll guide you to join or create one first
+
+**Once we determine the project, please tell me:**
+- What message do you want to broadcast?
+
+**I'll then:**
+1. Get the project members list
+2. Analyze if your message expects responses (questions, requests, assignments)
+3. Send with \`send_message\` using broadcast=true
+
+**CRITICAL - reply_expected Usage:**
+- Set \`reply_expected: true\` if your broadcast asks a question or requests action from team members
+- If you set it to \`true\`, you MUST immediately call \`receive_messages\` with \`wait=true\` to wait for replies
+- Set \`reply_expected: false\` if your broadcast is informational (announcements, updates, status reports)
+- This is a commitment: \`true\` means you will wait for responses, \`false\` means you won't`
+                  }
+                }
+              ]
+            };
+          }
+
+          case 'review': {
+            // Check status first to see which project to review
+            return {
+              messages: [
+                {
+                  role: 'user',
+                  content: {
+                    type: 'text',
+                    text: `I want to review project activity.
+
+**First, let me check your current status:**
+1. Read your working directory from \`<env>\` (look for "Working directory:")
+2. Use the \`status\` tool to see your projects and unread message counts
+
+**Then:**
+- If you're in exactly 1 project ‚Üí I'll review that one automatically
+- If you're in multiple projects ‚Üí I'll ask which one to review
+- If you're in 0 projects ‚Üí I'll suggest joining or creating a project
+
+**The review will show:**
+- üìã Project overview (name, description, created date)
+- üë• Team members (who's online, when they joined)
+- üì¨ Your unread messages (recent messages with previews)
+- üì¶ Available resources (shared documents and data)
+
+**I'll use these tools:**
+- \`get_project_info\` for project details and members
+- \`receive_messages\` for your inbox
+- \`list_resources\` for shared resources`
+                  }
+                }
+              ]
+            };
+          }
+
+          case 'share': {
+            // Check status to determine which project to share with
+            return {
+              messages: [
+                {
+                  role: 'user',
+                  content: {
+                    type: 'text',
+                    text: `I want to share a resource with the project team.
+
+**First, let me check your current status:**
+1. Read your working directory from \`<env>\` (look for "Working directory:")
+2. Use the \`status\` tool to see your projects
+
+**Then:**
+- If you're in exactly 1 project ‚Üí I'll ask for the resource details
+- If you're in multiple projects ‚Üí I'll ask which project first
+- If you're in 0 projects ‚Üí I'll guide you to join or create one
+
+**Please tell me:**
+- What's the resource title?
+- What does it contain? (brief description)
+- Do you have a file path to share, or will you provide inline content?
+
+**I'll then:**
+1. Generate a resource_id from the title
+2. Store it with \`store_resource\` (using source_path for files >50KB, content for smaller data)
+3. Set permissions (read: everyone, write: you)
+4. Broadcast a notification to the team with \`send_message\`
+
+**CRITICAL - reply_expected Usage:**
+When broadcasting the notification about the shared resource:
+- Set \`reply_expected: true\` if you want feedback, review, or acknowledgment from team members
+- If you set it to \`true\`, you MUST immediately call \`receive_messages\` with \`wait=true\` to wait for responses
+- Set \`reply_expected: false\` if this is just an FYI notification (most common for resource sharing)
+- This is a commitment: \`true\` means you will wait for responses, \`false\` means you won't`
+                  }
+                }
+              ]
+            };
+          }
+
+          case 'discuss': {
+            // Check status to see ongoing discussions
+            return {
+              messages: [
+                {
+                  role: 'user',
+                  content: {
+                    type: 'text',
+                    text: `I want to contribute to an ongoing project discussion.
+
+**First, let me check your current status:**
+1. Read your working directory from \`<env>\` (look for "Working directory:")
+2. Use the \`status\` tool to see your projects and unread messages
+
+**Then:**
+- If you're in exactly 1 project ‚Üí I'll show recent messages and ask for your response
+- If you're in multiple projects ‚Üí I'll ask which project first
+- If you have unread messages ‚Üí I'll show them for context
+- If you're in 0 projects ‚Üí I'll guide you to join one
+
+**Please tell me:**
+- What do you want to say or contribute?
+
+**I'll then:**
+1. Get recent messages with \`receive_messages\` for context
+2. Determine if this is a reply to someone specific or a general contribution
+3. Analyze if your message expects a response (questions, requests, assignments)
+4. Send your response with \`send_message\` (direct or broadcast as appropriate)
+
+**CRITICAL - reply_expected Usage:**
+- Set \`reply_expected: true\` if your message asks a question or requests action
+- If you set it to \`true\`, you MUST immediately call \`receive_messages\` with \`wait=true\` to wait for the reply
+- Set \`reply_expected: false\` if your message is informational or doesn't need a response
+- This is a commitment: \`true\` means you will wait, \`false\` means you won't`
+                  }
+                }
+              ]
+            };
+          }
+
+          case 'list': {
+            // Get all projects
+            const projects = await this.storage.listProjects();
+
+            if (projects.length === 0) {
+              return {
+                messages: [
+                  {
+                    role: 'user',
+                    content: {
+                      type: 'text',
+                      text: `üìã **No Projects Yet**
+
+No collaboration projects have been created yet. Be the first!
+
+**To get started**:
+- Use the **"create"** prompt to start a new project
+- Example: Create a project called "API Redesign" with goal "Coordinate frontend and backend"`
+                    }
+                  }
+                ]
+              };
+            }
+
+            const projectList = projects.map(p => {
+              return `### üìÅ ${p.name} (\`${p.project_id}\`)
+**Description**: ${p.description || '(No description)'}
+**Created**: ${new Date(p.created_at).toLocaleString()}`;
+            }).join('\n\n');
+
+            return {
+              messages: [
+                {
+                  role: 'user',
+                  content: {
+                    type: 'text',
+                    text: `üìã **Available Projects** (${projects.length})
+
+${projectList}
+
+**Next steps**:
+- Use **"join"** prompt with a project_id to join one of these projects
+- Use **"create"** prompt to start a new project
+- Use **"status"** prompt to see which projects you're already in`
+                  }
+                }
+              ]
+            };
+          }
+
+          case 'status': {
+            // Instruct Claude to get working_directory from <env> and use the status tool
+            return {
+              messages: [
+                {
+                  role: 'user',
+                  content: {
+                    type: 'text',
+                    text: `I want to see my Brainstorm project status for this working directory.
+
+**Please**:
+1. Read your working directory from the \`<env>\` context (look for "Working directory:")
+2. Use the \`status\` tool with the working_directory parameter set to that value
+
+The tool will show you all projects you've joined from this directory, including unread message counts.`
+                  }
+                }
+              ]
+            };
+          }
+
+          default:
+            throw new Error(`Prompt implementation not found: ${promptName}`);
+        }
+      } catch (error: unknown) {
+        // If error is from storage/validation, provide helpful context
+        if (error instanceof Error) {
+          return {
+            messages: [
+              {
+                role: 'user',
+                content: {
+                  type: 'text',
+                  text: `‚ùå **Error**: ${error.message}\n\nPlease check your arguments and try again.`
+                }
+              }
+            ]
+          };
+        }
+        throw error;
+      }
+    });
   }
 
   private setupProcessHandlers(): void {
diff --git a/src/storage.ts b/src/storage.ts
index b1b1fd1..f9b92d5 100644
--- a/src/storage.ts
+++ b/src/storage.ts
@@ -12,7 +12,9 @@ import type {
   Message,
   ResourceManifest,
   StoredResourceManifest,
-  SystemConfig
+  SystemConfig,
+  ClientIdentity,
+  ClientMembership
 } from './types.js';
 import {
   ValidationError,
@@ -394,6 +396,9 @@ export class FileSystemStorage {
   async joinProject(member: ProjectMember): Promise<void> {
     this.assertSafeId(member.project_id, 'project_id');
     this.assertSafeId(member.agent_name, 'agent_name');
+    if (member.client_id) {
+      this.assertSafeId(member.client_id, 'client_id');
+    }
 
     // Check if project exists
     const project = await this.getProjectMetadata(member.project_id);
@@ -407,12 +412,42 @@ export class FileSystemStorage {
 
     // Check if agent name is already taken
     const existing = await this.getProjectMember(member.project_id, member.agent_name);
+
     if (existing) {
-      throw new ConflictError(
-        'Agent name already taken in this project',
-        'AGENT_NAME_TAKEN',
-        { project_id: member.project_id, agent_name: member.agent_name }
-      );
+      // Smart reclaim logic: allow same client to reclaim their name
+      if (member.client_id && existing.client_id === member.client_id) {
+        // Same client reclaiming their name - preserve identity
+        member.joined_at = existing.joined_at; // Keep original join date
+        member.agent_id = existing.agent_id;    // Keep same agent_id
+        // Fall through to write updated member record
+      } else if (existing.client_id && member.client_id && existing.client_id !== member.client_id) {
+        // Different client - name truly taken
+        throw new ConflictError(
+          'Agent name already taken in this project by another client',
+          'AGENT_NAME_TAKEN',
+          { project_id: member.project_id, agent_name: member.agent_name }
+        );
+      } else if (!existing.client_id && !member.client_id) {
+        // Legacy: Both lack client_id - reject (backward compatible)
+        throw new ConflictError(
+          'Agent name already taken in this project',
+          'AGENT_NAME_TAKEN',
+          { project_id: member.project_id, agent_name: member.agent_name }
+        );
+      } else if (!existing.client_id && member.client_id) {
+        // Legacy member (no client_id) - FREE TO CLAIM
+        // Preserve identity continuity from the legacy member
+        member.joined_at = existing.joined_at; // Keep original join date
+        member.agent_id = existing.agent_id;    // Keep same agent_id
+        // Fall through to write updated member record with backfilled client_id
+      } else {
+        // Edge case: new member lacks client_id (shouldn't happen in v0.8.0+)
+        throw new ConflictError(
+          'Agent name already taken in this project',
+          'AGENT_NAME_TAKEN',
+          { project_id: member.project_id, agent_name: member.agent_name }
+        );
+      }
     }
 
     const memberPath = path.join(
@@ -1156,4 +1191,143 @@ export class FileSystemStorage {
       throw err;
     }
   }
+
+  // ============================================================================
+  // Client identity and session persistence operations (v0.8.0+)
+  // ============================================================================
+
+  async storeClientIdentity(clientId: string): Promise<void> {
+    this.assertSafeId(clientId, 'client_id');
+
+    const clientDir = path.join(this.root, 'clients', clientId);
+    await fs.mkdir(clientDir, { recursive: true });
+
+    const identityPath = path.join(clientDir, 'identity.json');
+
+    // Check if identity already exists
+    let identity: ClientIdentity;
+    try {
+      const existing = await fs.readFile(identityPath, 'utf-8');
+      identity = JSON.parse(existing);
+      identity.last_seen = new Date().toISOString();
+    } catch {
+      // New identity
+      identity = {
+        client_id: clientId,
+        created_at: new Date().toISOString(),
+        last_seen: new Date().toISOString()
+      };
+    }
+
+    await this.atomicWrite(identityPath, JSON.stringify(identity, null, 2));
+  }
+
+  async getClientIdentity(clientId: string): Promise<ClientIdentity | null> {
+    this.assertSafeId(clientId, 'client_id');
+
+    try {
+      const identityPath = path.join(this.root, 'clients', clientId, 'identity.json');
+      const content = await fs.readFile(identityPath, 'utf-8');
+      return JSON.parse(content);
+    } catch {
+      return null;
+    }
+  }
+
+  async recordClientMembership(
+    clientId: string,
+    projectId: string,
+    agentName: string,
+    projectName: string
+  ): Promise<void> {
+    this.assertSafeId(clientId, 'client_id');
+    this.assertSafeId(projectId, 'project_id');
+    this.assertSafeId(agentName, 'agent_name');
+
+    const clientDir = path.join(this.root, 'clients', clientId);
+    await fs.mkdir(clientDir, { recursive: true });
+
+    const membershipsPath = path.join(clientDir, 'memberships.json');
+
+    // Load existing memberships
+    let memberships: ClientMembership[] = [];
+    try {
+      const content = await fs.readFile(membershipsPath, 'utf-8');
+      memberships = JSON.parse(content);
+    } catch {
+      // No existing memberships
+    }
+
+    // Check if membership already exists
+    const existingIndex = memberships.findIndex(m => m.project_id === projectId);
+
+    if (existingIndex >= 0) {
+      // Update existing membership
+      memberships[existingIndex] = {
+        project_id: projectId,
+        agent_name: agentName,
+        project_name: projectName,
+        joined_at: memberships[existingIndex].joined_at // Keep original join date
+      };
+    } else {
+      // Add new membership
+      memberships.push({
+        project_id: projectId,
+        agent_name: agentName,
+        project_name: projectName,
+        joined_at: new Date().toISOString()
+      });
+    }
+
+    await this.atomicWrite(membershipsPath, JSON.stringify(memberships, null, 2));
+  }
+
+  async getClientMemberships(clientId: string): Promise<ClientMembership[]> {
+    this.assertSafeId(clientId, 'client_id');
+
+    try {
+      const membershipsPath = path.join(this.root, 'clients', clientId, 'memberships.json');
+      const content = await fs.readFile(membershipsPath, 'utf-8');
+      return JSON.parse(content);
+    } catch {
+      return [];
+    }
+  }
+
+  async removeClientMembership(clientId: string, projectId: string): Promise<void> {
+    this.assertSafeId(clientId, 'client_id');
+    this.assertSafeId(projectId, 'project_id');
+
+    const membershipsPath = path.join(this.root, 'clients', clientId, 'memberships.json');
+
+    try {
+      const content = await fs.readFile(membershipsPath, 'utf-8');
+      let memberships: ClientMembership[] = JSON.parse(content);
+
+      // Filter out the membership
+      memberships = memberships.filter(m => m.project_id !== projectId);
+
+      await this.atomicWrite(membershipsPath, JSON.stringify(memberships, null, 2));
+    } catch {
+      // No memberships file - nothing to do
+    }
+  }
+
+  async removeProjectFromAllClients(projectId: string): Promise<void> {
+    this.assertSafeId(projectId, 'project_id');
+
+    const clientsDir = path.join(this.root, 'clients');
+
+    try {
+      const clientDirs = await fs.readdir(clientsDir, { withFileTypes: true });
+
+      for (const clientDir of clientDirs) {
+        if (clientDir.isDirectory()) {
+          await this.removeClientMembership(clientDir.name, projectId);
+        }
+      }
+    } catch {
+      // No clients directory - nothing to do
+    }
+  }
 }
diff --git a/src/types.ts b/src/types.ts
index f42cdca..a0a23c8 100644
--- a/src/types.ts
+++ b/src/types.ts
@@ -17,6 +17,7 @@ export interface ProjectMember {
   project_id: string;
   agent_name: string; // friendly name within project (e.g., "frontend", "backend")
   agent_id: string; // globally unique ID (auto-generated)
+  client_id?: string; // v0.8.0: Client ID for session persistence and name reclaiming
   capabilities?: string[];
   labels?: Record<string, string>;
   joined_at: string;
@@ -74,3 +75,18 @@ export interface SystemConfig {
   max_long_poll_timeout_seconds: number;
   default_long_poll_timeout_seconds: number;
 }
+
+// Client identity for session persistence (v0.8.0+)
+export interface ClientIdentity {
+  client_id: string;
+  created_at: string;
+  last_seen: string;
+}
+
+// Client membership tracking for multi-project participation (v0.8.0+)
+export interface ClientMembership {
+  project_id: string;
+  agent_name: string;
+  project_name: string;
+  joined_at: string;
+}
